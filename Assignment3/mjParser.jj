// Program demo for CS321 Compilers and Language Design I Lab 4
// Blake Wellington
// Modified from:
// Jingke Li, Portland State University

// Starting program for Assignment 3.
//

// This option can be turned on to help debugging your program.
// options { DEBUG_PARSER=true; }

 options { LOOKAHEAD=2; }
// TODO Put LOOKAHEAD directive within the methods that require it.

PARSER_BEGIN(mjParser)
import java.io.*;
public class mjParser {
  public static void main(String [] args) {
    try {
      if (args.length == 1) {
	FileInputStream stream = new FileInputStream(args[0]);
	Ast.Program p = new mjParser(stream).Program();
	stream.close();
	p.dump();
      } else {
	System.out.println("Need a file name as command-line argument.");
      }
    } catch (TokenMgrError e) {
      System.err.println(e.toString());
    } catch (Exception e) {
      System.err.println(e.toString());
    }
  }
}
PARSER_END(mjParser)

//
// LEXER SECTION ---------------------------------------------------------------
//

SKIP : /* WHITE SPACE */
{
  " " | "\t" | "\n" | "\r" | "\f"
}

SKIP : /* COMMENTS */
{
  <SL_COMMENT:   "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <ML_COMMENT:   "/*" ( ~["*"] | (["*"])+ (~["/"]) )* (["*"])+ "/">
| <UNTERMINATED: "/*" ( ~["*"] | (["*"])+ (~["/"]) )* (["*"])+ >
    { if (true) throw new TokenMgrError("Unterminated multi-line comments ", 0); }  
}

TOKEN : /* KEYWORDS */
{
  <BOOLEAN: "boolean">   
| <CLASS:   "class">
| <ELSE:    "else">
| <EXTENDS: "extends">
| <FALSE:   "false">
| <IF:      "if">
| <INT:     "int">
| <MAIN:    "main">
| <NEW:     "new">
| <PUBLIC:  "public">
| <RETURN:  "return">
| <STATIC:  "static">
| <STRING:  "String">
| <PRINT:   "System.out.println">
| <TRUE:    "true">
| <VOID:    "void">         
| <WHILE:   "while">
| <#DIGIT:  ["0"-"9"]>
| <#LETTER: (["A"-"Z"]|["a"-"z"])>
}

TOKEN : /* length */
{
  <LENGTH: "length">
}

TOKEN : /* INTLITERAL */
{
  <INTLITERAL: (<DIGIT>)+> 
  { try { 
      Integer.parseInt(matchedToken.image); 
    } catch (Exception e) { 
	throw new TokenMgrError("Lexical error at line " + matchedToken.beginLine + 
				", column " + matchedToken.beginColumn + 
				". Integer overflow: " + matchedToken.image, 0);
    } 
  }
}

TOKEN : /* STRLITERAL */
{
  <STRLITERAL: ("\"" (~["\"","\n"])+ "\"")>
  { if (matchedToken.image.length() > 257) 
      throw new TokenMgrError("Lexical error at line " + matchedToken.beginLine + 
			      ", column " + matchedToken.beginColumn + 
			      ". String length over 255: " + matchedToken.image, 0); 
  }
}

TOKEN : /* ID */
{
  <ID: <LETTER> (<LETTER>|<DIGIT>|"_")*>
  { if (matchedToken.image.length() > 255) 
      throw new TokenMgrError("Lexical error at line " + matchedToken.beginLine + 
			      ", column " + matchedToken.beginColumn + 
			      ". Id length over 255: " + matchedToken.image, 0);
  }
}

//
// PARSER SECTION ---------------------------------------------------------------
//
// This version is based on the revised grammar of miniJava --- 
//   ambiguity, left-recursion, and common-prefixes have been addressed
//

// The Grammar:
//        ===================  My new Grammar  ===================
//        Program 		->	{ClassDecl}
//       
//        ClassDecl		->	"class" <ID> ["extends" <ID>] "{" {VarDecl} {MethodDecl} "}"
//        				
//        MethodDecl 	-> "public" 
//            		   (
//         	             ( Type | "void") <ID> "(" [Formals] )
//        		     | ( "static" "void" "main" "(" "String" "[" "]" <ID> )
//                	   ( ")" "{" {VarDecl} {Statement} "}")
//                 	   )
//        				
//        Formals 		-> 	Type <ID> {"," Type <ID>}
//        
//        VarDecl 		-> 	Type <ID> ["=" InitExpr] ";"
//        
//        Type 			-> 	(<BOOLEAN> | <INT>) ["[" "]"]
//        				| <ID>
//        				
//        Statement 		-> 	"{" {Statement} "}"
//        				| Lvalue ( ("=" InitExpr ) | ( "(" [Args] ")" ) ";"
//        				| "if" "(" Expr ")" Statement ["else" Statement]
//        				| "while" "(" Expr ")" Statement
//        				| "System.out.println" "(" [Expr | <STRLITERAL>] ")" ";"
//        				| "return" [Expr] ";"
//
//        Args 			-> 	Expr {"," Expr}
//        
//        InitExpr		->	"new" ((<BOOLEAN> | <INT>) "[" <INTLITERAL> "]") | (ID> "(" [Args] ")")
//        				| Expr
//        
//       
//        Expr		->	CondExpr ( "=" Expr )?
//        			| Lvalue ( ("(" [Args] ")") | ("." "length" "(" ")") )?
//        			| Literal
//        CondExpr		->	CondAndExpr ( "||" CondAndExpr )*
//        CondAndExpr	->	EqExpr ( "&&" EqExpr )*
//        EqExpr		->	RelExpr ( ( "==" | "!=" ) RelExpr )*
//        RelExpr		->	AddExpr ( ( "<" | ">" | "<=" | ">=" ) AddExpr )*
//        AddExpr		->	MultExpr ( ( "+" | "-" ) MultExpr )*
//        MultExpr	->	UnaryExpr ( ( "*" | "/" ) UnaryExpr )*
//        UnaryExpr		->	( "!" | "-" ) UnaryExpr
//        					| "(" Expr ")"
//        
//        Lvalue 		-> 	<ID> {"." <ID>} ["[" Expr "]"]
//        
//        Literal 		-> 	<INTLITERAL> | "true" | "false"


// Program -> {ClassDecl}
//
Ast.Program Program(): 
{ 
  Ast.ClassDecl c;
  Ast.ClassDeclList cl = new Ast.ClassDeclList();
}
{
  ( c=ClassDecl() {cl.add(c);} )* <EOF>
  { return new Ast.Program(cl); }
}

// ClassDecl	->	"class" <ID> ["extends" <ID>] "{" {VarDecl} {MethodDecl} "}"
Ast.ClassDecl ClassDecl(): 
{
  Ast.VarDecl v;
  Ast.MethodDecl m;
  Ast.MethodDeclList ml = new Ast.MethodDeclList();
  Ast.VarDeclList vl = new Ast.VarDeclList();
  Token class_token; 
  Token parent_token; 
  Ast.Id c;
  Ast.Id p = null;
}
{
  <CLASS> class_token=<ID> { c = new Ast.Id(class_token.image); } 
  [ <EXTENDS> parent_token=<ID>  { p = new Ast.Id(parent_token.image); } ] 
    "{" 
       ( v=VarDecl() { vl.add(v); } )* 
       ( m=MethodDecl() { ml.add(m); } )*
    "}"

  { return new Ast.ClassDecl(c, p, vl, ml); }
}

// MethodDecl 	-> "public" 
//                 (
//                      ( Type | "void") <ID> "(" [Formals] )
//        	      | ( "static" "void" "main" "(" "String" "[" "]" <ID> )
//                 ( ")" "{" {VarDecl} {Statement} "}")
//                 )
Ast.MethodDecl MethodDecl(): 
{
  Token tkn;
  Ast.Type t;
  Ast.Id mid;
  Ast.Formal f;
  Ast.FormalList fl = new Ast.FormalList();
  Ast.VarDecl v;
  Ast.VarDeclList vl = new Ast.VarDeclList();
  Ast.Stmt s;
  Ast.StmtList sl = new Ast.StmtList();
}
{
  <PUBLIC> (
    ( 
        ( t=Type() | <VOID> ) tkn=<ID> { mid=new Ast.Id(tkn.image); } "(" [ fl=Formals()]  ) 
      | ( <STATIC> <VOID> <MAIN> "(" <STRING> "[" "]" tkn=<ID> { mid=new Ast.Id(tkn.image); } ) 
    ) 
    ( ")" "{" (v=VarDecl() {vl.add(v); })* ( s=Statement() {sl.add(s); } )* "}" )

  { return new Ast.MethodDecl(t, mid, fl, vl, sl); }
}


// Formals -> Type <ID> {"," Type <ID>}
//
//So it should be:

//Formals production

//Ast.FormalList Formals(): {
//Ast.FormalList fl = new Ast.FormalList();
//}{
////actual work
//return fl;}

//}
Ast.FormalList Formals(): 
{
  Ast.FormalList fl = new Ast.FormalList();
  Ast.Formal f;
  Token tkn;
  Ast.Type t;
} 
{
   t=Type() tkn=<ID> {f = new Ast.Formal(t, new Ast.Id(tkn.image)); fl.add(f); } ( "," t=Type() tkn=<ID> {fl.add(new Ast.Formal(t, new Ast.Id(tkn.image))); } )*
  { return fl; }
}

// VarDecl -> Type <ID> ["=" InitExpr] ";"
//
Ast.VarDecl VarDecl(): 
{
  Ast.VarDecl v;
}
{
  Type() <ID> [ "=" InitExpr() ] ";"
  { return v; }
}

//        
//  Type 	-> 	("int" | "boolean") ["[" "]"]
//        		| <ID>
Ast.Type Type(): 
{
  Ast.Type t;
  Token tkn;
  boolean isArray = false;
}
{
  ( <INT> {t=new Ast.IntType(); } | <BOOLEAN> {t=new Ast.BoolType(); } ) ("[" "]" {isArray=true; })*
  | tkn=<ID> { t=new Ast.ObjType(new Ast.Id(tkn.image)); } // TODO fix t to get a real Type

  { if (isArray)
      t=new Ast.ArrayType(t);
    return t; }
}


//        				
// Statement 	-> 	"{" {Statement} "}"
//        		| Lvalue ( ("=" InitExpr ) | ( "(" [Args] ")" ) ";"
//        		| "if" "(" Expr ")" Statement ["else" Statement]
//        		| "while" "(" Expr ")" Statement
//        		| "System.out.println" "(" [Expr | <STRLITERAL>] ")" ";"
//        		| "return" [Expr] ";"
Ast.Stmt Statement(): 
{
  Ast.Stmt s;
}
{
	  ( "{" Statement() "}" )
	| Lvalue() ( ("=" InitExpr() ) | ( "(" (Args())*  ")" ) ) ";"
	| ( <IF> "(" Expr() ")" Statement() (<ELSE> Statement())? )
	| ( <WHILE> "(" Expr() ")" Statement() )
	| ( "System.out.println" "(" ( Expr() | <STRLITERAL> )? ")" ";" )
	| ( <RETURN> (Expr())? ";" )
  { return s; }
}

//        
// Expr		->	CondExpr ( "=" Expr )?
//        		| Lvalue ( ("(" [Args] ")") | ("." "length" "(" ")") )?
//        		| Literal
Ast.Exp Expr(): 
{
  Ast.Exp e;
}
{
	CondExpr() ( "=" Expr() )?
	| Lvalue() ( ("(" (Args())* ")") | ("." <LENGTH> "(" ")") )?
	| Literal()
  { return e; }
}

// CondExpr	->	CondAndExpr ( "||" CondAndExpr )*
Ast.Exp CondExpr(): 
{
  Ast.Exp e;
}
{
	CondAndExpr() ( "||" CondAndExpr() )*
}

// CondAndExpr	->	EqExpr ( "&&" EqExpr )*
Ast.Exp CondAndExpr(): 
{
  Ast.Exp e;
}
{
	EqExpr() ( "&&" EqExpr() )*
}
// EqExpr	->	RelExpr ( ( "==" | "!=" ) RelExpr )*
Ast.Exp EqExpr(): 
{
  Ast.Exp e;
}
{
  RelExpr() ( ( "==" | "!=" ) RelExpr() )*
}
// RelExpr	->	AddExpr ( ( "<" | ">" | "<=" | ">=" ) AddExpr )*
Ast.Exp RelExpr(): 
{
  Ast.Exp e;
}
{
  AddExpr() ( ( "<" | ">" | "<=" | ">=" ) AddExpr() )*
}
// AddExpr	->	MultExpr ( ( "+" | "-" ) MultExpr )*
Ast.Exp AddExpr(): 
{
  Ast.Exp e;
}
{
  MultExpr() ( ( "+" | "-" ) MultExpr() )*
}

// MultExpr	->	UnaryExpr ( ( "*" | "/" ) UnaryExpr )*
Ast.Exp MultExpr(): 
{
  Ast.Unop e1;
  Ast.Unop e2;
  Ast.BOP op;
}
{
  e1=UnaryExpr() 
  [ 
    ( 
      "*" { op = Ast.BOP.MUL; }
    | "/" { op = Ast.BOP.DIV; }
    ) 
    e2=UnaryExpr()
  ]
  { return new Ast.Binop(op, e1, e2); }
}

// UnaryExpr	->	( "!" | "-" ) UnaryExpr
//        		| "(" Expr ")"
Ast.Unop UnaryExpr(): 
{
  Ast.Unop e;
  Ast.UOP op;
}
{
  ( 
    "!" { op = Ast.UOP.NOT; }
  | "-" { op = Ast.UOP.NOT; } ) e=UnaryExpr()
  | "(" Expr() ")"
  { return new Ast.Unop(op, e); }
}

//  InitExpr	->	"new" ((<BOOLEAN> | <INT>) "[" <INTLITERAL> "]") | (ID> "(" [Args] ")")
//        		| Expr
Ast.Exp InitExpr(): 
// In that production, you're making an array and the Ast.NewArray constructor 
// requires a type. That's what the ( "int" | "boolean" ) is for.

//Something like: 
//   ( "int" { Ast.Type = new Ast.IntType();} | "boolean" { Ast.Type = new Ast.BoolType(); } )
//is what you want.

{
  Ast.Type t;
  Ast.NewArray a;
}
{
  <NEW>
  (
    ( 
      (   <BOOLEAN> {t = new Ast.BoolType(); }
        | <INT>{t = new Ast.IntType(); }) 
          ("[" <INTLITERAL> "]" )
    | ( <ID> "(" (Args())? ")" )
    )
  | Expr()
  )
}

//        
// Args 	-> 	Expr {"," Expr}
//        
Ast.ExpList Args(): 
{
  Ast.Exp e;
  Ast.ExpList el;
}
{
  e=Expr() {el.add(e); } ( "," e=Expr() {el.add(e); } )*
  { return el; }
}

// Lvalue 	-> 	<ID> {"." <ID>} ["[" Expr "]"]
Ast.Exp Lvalue(): 
{
  Ast.Exp e;
}
{
	<ID> ("." <ID>)* ("[" Expr() "]")?
  { return e; }
}

//        
// Literal 	-> 	<INTLITERAL> | "true" | "false"
Ast.Exp Literal(): 
{
  Token tkn;
  Ast.Exp e;
}
{
      tkn=<INTLITERAL> { e = new Ast.IntVal(Integer.parseInt(tkn.image)); }
      | tkn=<TRUE> { e = new Ast.True(); }
      | tkn=<FALSE>{ e = new Ast.False(); }
  { return e; }
}
