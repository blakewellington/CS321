// Program demo for CS321 Compilers and Language Design I Lab 4
// Blake Wellington
// Modified from:
// Jingke Li, Portland State University

// Starting program for Assignment 3.
//

// This option can be turned on to help debugging your program.
// options { DEBUG_PARSER=true; }

// options { LOOKAHEAD=2; }
// TODO Put LOOKAHEAD directive within the methods that require it.

PARSER_BEGIN(mjParser)
import java.io.*;
public class mjParser {
  public static void main(String [] args) {
    try {
      if (args.length == 1) {
	FileInputStream stream = new FileInputStream(args[0]);
	Ast.Program p = new mjParser(stream).Program();
	stream.close();
	p.dump();
      } else {
	System.out.println("Need a file name as command-line argument.");
      }
    } catch (TokenMgrError e) {
      System.err.println(e.toString());
    } catch (Exception e) {
      System.err.println(e.toString());
    }
  }
}
PARSER_END(mjParser)

//
// LEXER SECTION ---------------------------------------------------------------
//

SKIP : /* WHITE SPACE */
{
  " " | "\t" | "\n" | "\r" | "\f"
}

SKIP : /* COMMENTS */
{
  <SL_COMMENT:   "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <ML_COMMENT:   "/*" ( ~["*"] | (["*"])+ (~["/"]) )* (["*"])+ "/">
| <UNTERMINATED: "/*" ( ~["*"] | (["*"])+ (~["/"]) )* (["*"])+ >
    { if (true) throw new TokenMgrError("Unterminated multi-line comments ", 0); }  
}

TOKEN : /* KEYWORDS */
{
  <BOOLEAN: "boolean">   
| <CLASS:   "class">
| <ELSE:    "else">
| <EXTENDS: "extends">
| <FALSE:   "false">
| <IF:      "if">
| <INT:     "int">
| <MAIN:    "main">
| <NEW:     "new">
| <PUBLIC:  "public">
| <RETURN:  "return">
| <STATIC:  "static">
| <STRING:  "String">
| <PRINT:   "System.out.println">
| <TRUE:    "true">
| <VOID:    "void">         
| <WHILE:   "while">
| <#DIGIT:  ["0"-"9"]>
| <#LETTER: (["A"-"Z"]|["a"-"z"])>
}

TOKEN : /* length */
{
  <LENGTH: "length">
}

TOKEN : /* INTLITERAL */
{
  <INTLITERAL: (<DIGIT>)+> 
  { try { 
      Integer.parseInt(matchedToken.image); 
    } catch (Exception e) { 
	throw new TokenMgrError("Lexical error at line " + matchedToken.beginLine + 
				", column " + matchedToken.beginColumn + 
				". Integer overflow: " + matchedToken.image, 0);
    } 
  }
}

TOKEN : /* STRLITERAL */
{
  <STRLITERAL: ("\"" (~["\"","\n"])+ "\"")>
  { if (matchedToken.image.length() > 257) 
      throw new TokenMgrError("Lexical error at line " + matchedToken.beginLine + 
			      ", column " + matchedToken.beginColumn + 
			      ". String length over 255: " + matchedToken.image, 0); 
  }
}

TOKEN : /* ID */
{
  <ID: <LETTER> (<LETTER>|<DIGIT>|"_")*>
  { if (matchedToken.image.length() > 255) 
      throw new TokenMgrError("Lexical error at line " + matchedToken.beginLine + 
			      ", column " + matchedToken.beginColumn + 
			      ". Id length over 255: " + matchedToken.image, 0);
  }
}

//
// PARSER SECTION ---------------------------------------------------------------
//
// This version is based on the revised grammar of miniJava --- 
//   ambiguity, left-recursion, and common-prefixes have been addressed
//

// The Grammar:
//        ===================  My new Grammar  ===================
//        Program 		->	{ClassDecl}
//       
//        ClassDecl		->	"class" <ID> ["extends" <ID>] "{" {VarDecl} {MethodDecl} "}"
//        				
//        MethodDecl 		-> 	"public" (Type | "void") <ID> "(" [Formals] ")" "{" {VarDecl} {Statement} "}"
//        				| "public" "static" "void" "main" "(" "String" "[" "]" <ID> ")" "{" {VarDecl} {Statement} "}"
//        				
//        Formals 		-> 	Type <ID> {"," Type <ID>}
//        
//        VarDecl 		-> 	Type <ID> ["=" InitExpr] ";"
//        
//        Type 			-> 	("int" | "boolean") ["[" "]"]
//        				| <ID>
//        				
//        Statement 		-> 	"{" {Statement} "}"
//        				| Lvalue ( ("=" InitExpr ) | ( Lvalue "(" [Args] ")" ) ";"
//        				| "if" "(" Expr ")" Statement ["else" Statement]
//        				| "while" "(" Expr ")" Statement
//        				| "System.out.println" "(" [Expr | <STRLITERAL>] ")" ";"
//        				| "return" [Expr] ";"
//       
//        Expr		->	CondExpr ( "=" Expr )?
//        				| Lvalue ( ("(" [Args] ")") | ("." "length" "(" ")") )?
//        				| Literal
//        CondExpr		->	CondAndExpr ( "||" CondAndExpr )*
//        CondAndExpr	->	EqExpr ( "&&" EqExpr )*
//        EqExpr		->	RelExpr ( ( "==" | "!=" ) RelExpr )*
//        RelExpr		->	AddExpr ( ( "<" | ">" | "<=" | ">=" ) AddExpr )*
//        AddExpr		->	MultExpr ( ( "+" | "-" ) MultExpr )*
//        MultExpr	->	UnaryExpr ( ( "*" | "/" ) UnaryExpr )*
//        UnaryExpr		->	( "!" | "-" ) UnaryExpr
//        					| "(" Expr ")"
//        
//        InitExpr		->	"new" PrimitiveType "[" <INTLITERAL> "]"
//        				|	"new" ID> "(" [Args] ")"
//        				| Expr
//        
//        Args 			-> 	Expr {"," Expr}
//        
//        PrimitiveType		-> ("boolean" | "int")
//        
//        Lvalue 		-> 	<ID> {"." <ID>} ["[" Expr "]"]
//        
//        Literal 		-> 	<INTLITERAL> | "true" | "false"


// Program -> {ClassDecl}
//
Ast.Program Program(): 
{ 
  Ast.ClassDecl c;
  Ast.ClassDeclList cl = new Ast.ClassDeclList();
}
{
  ( c=ClassDecl() {cl.add(c);} )*
  { return new Ast.Program(cl); }
}

// ClassDecl	->	"class" <ID> ["extends" <ID>] "{" {VarDecl} {MethodDecl} "}"
Ast.ClassDeclList ClassDecl(): {}
{
	<CLASS> <ID> [ <EXTENDS> <ID> ] "{" ( VarDecl() )* ( MethodDecl() )* "}"
}

// MethodDecl 	-> 	"public" (Type | "void") <ID> "(" [Formals] ")" "{" {VarDecl} {Statement} "}"
//        		| "public" "static" "void" "main" "(" "String" "[" "]" <ID> ")" "{" {VarDecl} {Statement} "}"
void MethodDecl(): {}
{
//  "public" (Type() | "void") <ID> "(" [ Formals() ] ")" "{" ( VarDecl() )* ( Statement() )* "}"
//  |  "public" "static" "void" "main" "(" "String" "[" "]" <ID> ")" "{" ( VarDecl() )* ( Statement() )* "}"
  <PUBLIC> (
    ( 
      (Type() | <VOID>) <ID> "(" [ Formals() ] ")" ) 
      | ( <STATIC> <VOID> <MAIN> "(" <STRING> "[" "]" <ID> ")" ) 
    ) 
  "{" ( LOOKAHEAD(2)VarDecl() )* ( Statement() )* "}"
}


// Formals -> Type <ID> {"," Type <ID>}
//
void Formals(): {} 
{
   Type() <ID> ( "," Type() <ID> )*
}

// VarDecl -> Type <ID> ["=" InitExpr] ";"
//
void VarDecl(): {}
{
  Type() <ID> [ "=" InitExpr() ] ";"
}

//        
//  Type 	-> 	("int" | "boolean") ["[" "]"]
//        		| <ID>
void Type(): {}
{
  ( <INT> | <BOOLEAN> ) ("[" "]")*
  | <ID>
}


//        				
// Statement 	-> 	"{" {Statement} "}"
//        		| Lvalue ( ("=" InitExpr ) | ( Lvalue "(" [Args] ")" ) ";"
//        		| "if" "(" Expr ")" Statement ["else" Statement]
//        		| "while" "(" Expr ")" Statement
//        		| "System.out.println" "(" [Expr | <STRLITERAL>] ")" ";"
//        		| "return" [Expr] ";"
void Statement(): {}
{
	( "{" Statement() "}" )
	| Lvalue() ( ("=" InitExpr() ) | ( Lvalue() "(" (Args())*  ")" ) ) ";"
	| ( <IF> "(" Expr() ")" Statement() (LOOKAHEAD(2)<ELSE> Statement())* )
	| ( <WHILE> "(" Expr() ")" Statement() )
	| ( "System.out.println" "(" ( Expr() | <STRLITERAL> )* ")" ";" )
	| ( <RETURN> (Expr())* ";" )
}

//        
// Expr		->	CondExpr ( "=" Expr )?
//        		| Lvalue ( ("(" [Args] ")") | ("." "length" "(" ")") )?
//        		| Literal
void Expr(): {}
{
	CondExpr() ( "=" Expr() )?
	| Lvalue() ( ("(" (LOOKAHEAD(2)Args())* ")") | ("." <LENGTH> "(" ")") )?
	| Literal()
}

// CondExpr	->	CondAndExpr ( "||" CondAndExpr )*
void CondExpr(): {}
{
	CondAndExpr() ( "||" CondAndExpr() )*
}

// CondAndExpr	->	EqExpr ( "&&" EqExpr )*
void CondAndExpr(): {}
{
	EqExpr() ( "&&" EqExpr() )*
}
// EqExpr	->	RelExpr ( ( "==" | "!=" ) RelExpr )*
void EqExpr(): {}
{
  RelExpr() ( ( "==" | "!=" ) RelExpr() )*
}
// RelExpr	->	AddExpr ( ( "<" | ">" | "<=" | ">=" ) AddExpr )*
void RelExpr(): {}
{
  AddExpr() ( ( "<" | ">" | "<=" | ">=" ) AddExpr() )*
}
// AddExpr	->	MultExpr ( ( "+" | "-" ) MultExpr )*
void AddExpr(): {}
{
  MultExpr() (LOOKAHEAD(2) ( "+" | "-" ) MultExpr() )*
}

// MultExpr	->	UnaryExpr ( ( "*" | "/" ) UnaryExpr )*
void MultExpr(): {}
{
  UnaryExpr() ( ( "*" | "/" ) UnaryExpr() )*
}

// UnaryExpr	->	( "!" | "-" ) UnaryExpr
//        		| "(" Expr ")"
void UnaryExpr(): {}
{
  ( "!" | "-" ) UnaryExpr()
  | "(" Expr() ")"
}

//        
// InitExpr	->	"new" PrimitiveType "[" <INTLITERAL> "]"
//        	|	"new" ID> "(" [Args] ")"
//        	| Expr
void InitExpr(): {}
{
  <NEW>
  (
    ( PrimitiveType() "[" <INTLITERAL> "]" )
    | ( <ID> "(" (Args())* ")" )
  )
  | Expr()

//	"new" PrimitiveType() "[" <INTLITERAL> "]"
//	| "new" <ID> "(" (Args())* ")"
//	| Expr()
}

//        
// Args 	-> 	Expr {"," Expr}
//        
void Args(): {}
{
	Expr() (LOOKAHEAD(2) "," Expr() )*
}

// PrimitiveType	-> ("boolean" | "int")
//        
void PrimitiveType(): {}
{
	(<BOOLEAN> | <INT>)
}
// Lvalue 	-> 	<ID> {"." <ID>} ["[" Expr "]"]
void Lvalue(): {}
{
	<ID> (LOOKAHEAD(2)"." <ID>)* ("[" Expr() "]")?
}
//        
// Literal 	-> 	<INTLITERAL> | "true" | "false"
void Literal(): {}
{
	<INTLITERAL> | <TRUE> | <FALSE>
}
